import {
  BackSide,
  Box3,
  BufferAttribute,
  BufferGeometry,
  Color,
  DoubleSide,
  FrontSide,
  Group,
  InstancedMesh,
  Line3,
  LineBasicMaterial,
  LineSegments,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshPhongMaterial,
  Plane,
  Ray,
  Sphere,
  SphereGeometry,
  Triangle,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-DPMNFJ3R.js";

// node_modules/three-mesh-bvh/src/core/Constants.js
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var CONTAINED = 2;
var TRIANGLE_INTERSECT_COST = 1.25;
var TRAVERSAL_COST = 1;
var BYTES_PER_NODE = 6 * 4 + 4 + 4;
var IS_LEAFNODE_FLAG = 65535;
var FLOAT32_EPSILON = Math.pow(2, -24);

// node_modules/three-mesh-bvh/src/core/MeshBVHNode.js
var MeshBVHNode = class {
  constructor() {
  }
};

// node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js
function arrayToBox(nodeIndex32, array, target) {
  target.min.x = array[nodeIndex32];
  target.min.y = array[nodeIndex32 + 1];
  target.min.z = array[nodeIndex32 + 2];
  target.max.x = array[nodeIndex32 + 3];
  target.max.y = array[nodeIndex32 + 4];
  target.max.z = array[nodeIndex32 + 5];
  return target;
}
function makeEmptyBounds(target) {
  target[0] = target[1] = target[2] = Infinity;
  target[3] = target[4] = target[5] = -Infinity;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target) {
  target.set(source);
}
function unionBounds(a, b, target) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b[d];
    target[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b[d3];
    target[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}

// node_modules/three-mesh-bvh/src/core/buildFunctions.js
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    let index;
    if (vertexCount > 65535) {
      index = new Uint32Array(new BufferConstructor(4 * vertexCount));
    } else {
      index = new Uint16Array(new BufferConstructor(2 * vertexCount));
    }
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getRootIndexRanges(geo) {
  if (!geo.groups || !geo.groups.length) {
    return [{ offset: 0, count: geo.index.count / 3 }];
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  for (const group of geo.groups) {
    rangeBoundaries.add(group.start);
    rangeBoundaries.add(group.start + group.count);
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);
  for (let i = 0; i < sortedBoundaries.length - 1; i++) {
    const start = sortedBoundaries[i], end = sortedBoundaries[i + 1];
    ranges.push({ offset: start / 3, count: (end - start) / 3 });
  }
  return ranges;
}
function getBounds(triangleBounds, offset, count, target, centroidTarget = null) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const includeCentroid = centroidTarget !== null;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx)
      minx = lx;
    if (rx > maxx)
      maxx = rx;
    if (includeCentroid && cx < cminx)
      cminx = cx;
    if (includeCentroid && cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny)
      miny = ly;
    if (ry > maxy)
      maxy = ry;
    if (includeCentroid && cy < cminy)
      cminy = cy;
    if (includeCentroid && cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz)
      minz = lz;
    if (rz > maxz)
      maxz = rz;
    if (includeCentroid && cz < cminz)
      cminz = cz;
    if (includeCentroid && cz > cmaxz)
      cmaxz = cz;
  }
  target[0] = minx;
  target[1] = miny;
  target[2] = minz;
  target[3] = maxx;
  target[4] = maxy;
  target[5] = maxz;
  if (includeCentroid) {
    centroidTarget[0] = cminx;
    centroidTarget[1] = cminy;
    centroidTarget[2] = cminz;
    centroidTarget[3] = cmaxx;
    centroidTarget[4] = cmaxy;
    centroidTarget[5] = cmaxz;
  }
}
function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    if (cx < cminx)
      cminx = cx;
    if (cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    if (cy < cminy)
      cminy = cy;
    if (cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    if (cz < cminz)
      cminz = cz;
    if (cz > cmaxz)
      cmaxz = cz;
  }
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function partition(index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
        let t1 = triangleBounds[left * 6 + i * 2 + 0];
        triangleBounds[left * 6 + i * 2 + 0] = triangleBounds[right * 6 + i * 2 + 0];
        triangleBounds[right * 6 + i * 2 + 0] = t1;
        let t2 = triangleBounds[left * 6 + i * 2 + 1];
        triangleBounds[left * 6 + i * 2 + 1] = triangleBounds[right * 6 + i * 2 + 1];
        triangleBounds[right * 6 + i * 2 + 1] = t2;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
var BIN_COUNT = 32;
var binsSort = (a, b) => a.candidate - b.candidate;
var sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c = cStart; c < cEnd; c += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT; i++) {
          const bin = sahBins[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT)
            binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT - 2; i >= 0; i--) {
          const bin = sahBins[i];
          const nextBin = sahBins[i + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT - 1; i++) {
          const bin = sahBins[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i = offset, end = offset + count; i < end; i++) {
    avg += triangleBounds[i * 6 + axis * 2];
  }
  return avg / count;
}
function computeTriangleBounds(geo, fullBounds) {
  makeEmptyBounds(fullBounds);
  const posAttr = geo.attributes.position;
  const index = geo.index.array;
  const triCount = index.length / 3;
  const triangleBounds = new Float32Array(triCount * 6);
  const normalized = posAttr.normalized;
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = 0; tri < triCount; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai, bi, ci;
    if (normalized) {
      ai = index[tri3 + 0];
      bi = index[tri3 + 1];
      ci = index[tri3 + 2];
    } else {
      ai = index[tri3 + 0] * stride + bufferOffset;
      bi = index[tri3 + 1] * stride + bufferOffset;
      ci = index[tri3 + 2] * stride + bufferOffset;
    }
    for (let el = 0; el < 3; el++) {
      let a, b, c;
      if (normalized) {
        a = posAttr[getters[el]](ai);
        b = posAttr[getters[el]](bi);
        c = posAttr[getters[el]](ci);
      } else {
        a = posArr[ai + el];
        b = posArr[bi + el];
        c = posArr[ci + el];
      }
      let min = a;
      if (b < min)
        min = b;
      if (c < min)
        min = c;
      let max = a;
      if (b > max)
        max = b;
      if (c > max)
        max = c;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
      if (min < fullBounds[el])
        fullBounds[el] = min;
      if (max > fullBounds[el + 3])
        fullBounds[el + 3] = max;
    }
  }
  return triangleBounds;
}
function buildTree(geo, options) {
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geo);
      }
    }
    if (count <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);
    if (split.axis === -1) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const splitOffset = partition(indexArray, triangleBounds, offset, count, split);
    if (splitOffset === offset || splitOffset === offset + count) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset;
      const lcount = splitOffset - offset;
      node.left = left;
      left.boundingData = new Float32Array(6);
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count - lcount;
      node.right = right;
      right.boundingData = new Float32Array(6);
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
  ensureIndex(geo, options);
  const fullBounds = new Float32Array(6);
  const cacheCentroidBoundingData = new Float32Array(6);
  const triangleBounds = computeTriangleBounds(geo, fullBounds);
  const indexArray = geo.index.array;
  const maxDepth = options.maxDepth;
  const verbose = options.verbose;
  const maxLeafTris = options.maxLeafTris;
  const strategy = options.strategy;
  const onProgress = options.onProgress;
  const totalTriangles = geo.index.count / 3;
  let reachedMaxDepth = false;
  const roots = [];
  const ranges = getRootIndexRanges(geo);
  if (ranges.length === 1) {
    const range = ranges[0];
    const root = new MeshBVHNode();
    root.boundingData = fullBounds;
    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);
    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
    roots.push(root);
  } else {
    for (let range of ranges) {
      const root = new MeshBVHNode();
      root.boundingData = new Float32Array(6);
      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);
      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
      roots.push(root);
    }
  }
  return roots;
}
function buildPackedTree(geo, options) {
  const roots = buildTree(geo, options);
  let float32Array;
  let uint32Array;
  let uint16Array;
  const packedRoots = [];
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let i = 0; i < roots.length; i++) {
    const root = roots[i];
    let nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    float32Array = new Float32Array(buffer);
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    populateBuffer(0, root);
    packedRoots.push(buffer);
  }
  return packedRoots;
  function countNodes(node) {
    if (node.count) {
      return 1;
    } else {
      return 1 + countNodes(node.left) + countNodes(node.right);
    }
  }
  function populateBuffer(byteOffset, node) {
    const stride4Offset = byteOffset / 4;
    const stride2Offset = byteOffset / 2;
    const isLeaf = !!node.count;
    const boundingData = node.boundingData;
    for (let i = 0; i < 6; i++) {
      float32Array[stride4Offset + i] = boundingData[i];
    }
    if (isLeaf) {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    } else {
      const left = node.left;
      const right = node.right;
      const splitAxis = node.splitAxis;
      let nextUnusedPointer;
      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);
      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      }
      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);
      uint32Array[stride4Offset + 7] = splitAxis;
      return nextUnusedPointer;
    }
  }
}

// node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js
var SeparatingAxisBounds = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val = p[field];
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val = axis.dot(p);
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z + boxMax.z * (1 - z);
          const val = axis.dot(p);
          min = Math.min(val, min);
          max = Math.max(val, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
var areIntersecting = function() {
  const cacheSatBounds = new SeparatingAxisBounds();
  return function areIntersecting2(shape1, shape2) {
    const points1 = shape1.points;
    const satAxes1 = shape1.satAxes;
    const satBounds1 = shape1.satBounds;
    const points2 = shape2.points;
    const satAxes2 = shape2.satAxes;
    const satBounds2 = shape2.satBounds;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds1[i];
      const sa = satAxes1[i];
      cacheSatBounds.setFromPoints(sa, points2);
      if (sb.isSeparated(cacheSatBounds))
        return false;
    }
    for (let i = 0; i < 3; i++) {
      const sb = satBounds2[i];
      const sa = satAxes2[i];
      cacheSatBounds.setFromPoints(sa, points1);
      if (sb.isSeparated(cacheSatBounds))
        return false;
    }
  };
}();

// node_modules/three-mesh-bvh/src/math/MathUtilities.js
var closestPointLineToLine = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v2 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v2);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
}();
var closestPointsSegmentToSegment = function() {
  const paramResult = new Vector2();
  const temp12 = new Vector3();
  const temp22 = new Vector3();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target2);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp12;
      const closestPoint2 = temp22;
      l1.closestPointToPoint(p2, true, temp12);
      l2.closestPointToPoint(p, true, temp22);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
var sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere, triangle) {
    const { radius, center } = sphere;
    const { a, b, c } = triangle;
    lineTemp.start = a;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius)
      return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius)
      return true;
    lineTemp.start = b;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius)
      return true;
    const plane = triangle.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle.containsPoint(pp);
      if (cp)
        return true;
    }
    return false;
  };
}();

// node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js
var ZERO_EPSILON = 1e-15;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
var ExtendedTriangle = class extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle(sphere, this);
  }
  update() {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
};
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(start);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  const dir = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector3();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i = 0; i < 3; i++) {
      const { start, end } = edge;
      start.copy(points[i]);
      end.copy(points[(i + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero(plane.distanceToPoint(start));
      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start);
      }
      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds1[i];
        const sa = satAxes1[i];
        cachedSatBounds.setFromPoints(sa, arr2);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds2[i];
        const sa = satAxes2[i];
        cachedSatBounds.setFromPoints(sa, arr1);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      for (let i = 0; i < 4; i++) {
        const sa1 = satAxes1[i];
        for (let i2 = 0; i2 < 4; i2++) {
          const sa2 = satAxes2[i2];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2))
            return false;
        }
      }
      if (target) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target.start.set(0, 0, 0);
        target.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target) {
          target.start.copy(edge1.end);
          target.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target) {
          target.start.copy(edge2.end);
          target.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target.start.copy(edge1.start);
        } else {
          target.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target.end.copy(edge1.end);
        } else {
          target.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
ExtendedTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1)
          lineTarget.getCenter(target1);
        if (target2)
          lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(point);
        if (target2)
          target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(thisVec);
        if (target2)
          target2.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point);
          if (target2)
            target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/math/OrientedBox.js
var OrientedBox = class {
  constructor(min, max, matrix) {
    this.isOrientedBox = true;
    this.min = new Vector3();
    this.max = new Vector3();
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min)
      this.min.copy(min);
    if (max)
      this.max.copy(max);
    if (matrix)
      this.matrix.copy(matrix);
  }
  set(min, max, matrix) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = function() {
  return function update() {
    const matrix = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;
          const v = points[i];
          v.x = x ? max.x : min.x;
          v.y = y ? max.y : min.y;
          v.z = z ? max.z : min.z;
          v.applyMatrix4(matrix);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds))
      return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds))
        return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle.isExtendedTriangle) {
      saTri.copy(triangle);
      saTri.update();
      triangle = saTri;
    } else if (triangle.needsUpdate) {
      triangle.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle.a;
    pointsArr[1] = triangle.b;
    pointsArr[2] = triangle.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa = satAxes[i];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const triSatBounds = triangle.satBounds;
    const triSatAxes = triangle.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = function() {
  return function closestPointToPoint(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields2 = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(p);
        if (target2)
          target2.copy(point2);
        if (dist < threshold2)
          return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields2[i];
          const f2 = xyzFields2[nextIndex];
          const f3 = xyzFields2[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max[f2];
          start[f3] = i2 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i2 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1)
              target1.copy(point1);
            if (target2)
              target2.copy(point2);
            if (dist < threshold2)
              return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point1);
          if (target2)
            target2.copy(point2);
          if (dist < threshold2)
            return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _normalA = new Vector3();
var _normalB = new Vector3();
var _normalC = new Vector3();
var _intersectionPoint = new Vector3();
function checkIntersection(ray2, pA, pB, pC, point, side) {
  let intersect;
  if (side === BackSide) {
    intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray2.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  const distance = ray2.origin.distanceTo(point);
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side) {
  _vA.fromBufferAttribute(position, a);
  _vB.fromBufferAttribute(position, b);
  _vC.fromBufferAttribute(position, c);
  const intersection = checkIntersection(ray2, _vA, _vB, _vC, _intersectionPoint, side);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv1) {
      _uvA.fromBufferAttribute(uv1, a);
      _uvB.fromBufferAttribute(uv1, b);
      _uvC.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray2.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
  }
  return intersection;
}
function intersectTri(geo, side, ray2, tri, intersections) {
  const triOffset = tri * 3;
  const a = geo.index.getX(triOffset);
  const b = geo.index.getX(triOffset + 1);
  const c = geo.index.getX(triOffset + 2);
  const { position, normal, uv, uv1 } = geo.attributes;
  const intersection = checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections)
      intersections.push(intersection);
    return intersection;
  }
  return null;
}

// node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js
function intersectTris(geo, side, ray2, offset, count, intersections) {
  for (let i = offset, end = offset + count; i < end; i++) {
    intersectTri(geo, side, ray2, i, intersections);
  }
}
function intersectClosestTri(geo, side, ray2, offset, count) {
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    const intersection = intersectTri(geo, side, ray2, i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}

// node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js
function setTriangle(tri, i, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i);
    i1 = index.getX(i + 1);
    i2 = index.getX(i + 2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i2);
  tc.y = pos.getY(i2);
  tc.z = pos.getZ(i2);
}
function iterateOverTriangles(offset, count, geometry, intersectsTriangleFunc, contained, depth, triangle) {
  const index = geometry.index;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    setTriangle(triangle, i * 3, index, pos);
    triangle.needsUpdate = true;
    if (intersectsTriangleFunc(triangle, i, contained, depth)) {
      return true;
    }
  }
  return false;
}
var tempV1 = new Vector3();
var tempV2 = new Vector3();
var tempV3 = new Vector3();
var tempUV1 = new Vector2();
var tempUV2 = new Vector2();
var tempUV3 = new Vector2();

// node_modules/three-mesh-bvh/src/utils/PrimitivePool.js
var PrimitivePool = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};

// node_modules/three-mesh-bvh/src/core/nodeBufferFunctions.js
function IS_LEAF(n16, uint16Array) {
  return uint16Array[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function COUNT(n16, uint16Array) {
  return uint16Array[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array) {
  return uint32Array[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}

// node_modules/three-mesh-bvh/src/core/castFunctions.js
var boundingBox = new Box3();
var boxIntersection = new Vector3();
var xyzFields = ["x", "y", "z"];
function raycast(nodeIndex32, geometry, side, ray2, intersects) {
  let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris(geometry, side, ray2, offset, count, intersects);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray2, boxIntersection)) {
      raycast(leftIndex, geometry, side, ray2, intersects);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray2, boxIntersection)) {
      raycast(rightIndex, geometry, side, ray2, intersects);
    }
  }
}
function raycastFirst(nodeIndex32, geometry, side, ray2) {
  let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri(geometry, side, ray2, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = xyzFields[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray2, boxIntersection);
    const c1Result = c1Intersection ? raycastFirst(c1, geometry, side, ray2) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray2, boxIntersection);
    const c2Result = c2Intersection ? raycastFirst(c2, geometry, side, ray2) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
var shapecast = function() {
  let _box12, _box22;
  const boxStack = [];
  const boxPool = new PrimitivePool(() => new Box3());
  return function shapecast2(...args) {
    _box12 = boxPool.getPrimitive();
    _box22 = boxPool.getPrimitive();
    boxStack.push(_box12, _box22);
    const result = shapecastTraverse(...args);
    boxPool.releasePrimitive(_box12);
    boxPool.releasePrimitive(_box22);
    boxStack.pop();
    boxStack.pop();
    const length = boxStack.length;
    if (length > 0) {
      _box22 = boxStack[length - 1];
      _box12 = boxStack[length - 2];
    }
    return result;
  };
  function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
    function getLeftOffset(nodeIndex322) {
      let nodeIndex162 = nodeIndex322 * 2, uint16Array2 = _uint16Array, uint32Array2 = _uint32Array;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2);
    }
    function getRightEndOffset(nodeIndex322) {
      let nodeIndex162 = nodeIndex322 * 2, uint16Array2 = _uint16Array, uint32Array2 = _uint32Array;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array2);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2) + COUNT(nodeIndex162, uint16Array2);
    }
    let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;
    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
    if (isLeaf) {
      const offset = OFFSET(nodeIndex32, uint32Array);
      const count = COUNT(nodeIndex16, uint16Array);
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box12);
      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box12);
    } else {
      const left = LEFT_NODE(nodeIndex32);
      const right = RIGHT_NODE(nodeIndex32, uint32Array);
      let c1 = left;
      let c2 = right;
      let score1, score2;
      let box1, box2;
      if (nodeScoreFunc) {
        box1 = _box12;
        box2 = _box22;
        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
        arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
        score1 = nodeScoreFunc(box1);
        score2 = nodeScoreFunc(box2);
        if (score2 < score1) {
          c1 = right;
          c2 = left;
          const temp5 = score1;
          score1 = score2;
          score2 = temp5;
          box1 = box2;
        }
      }
      if (!box1) {
        box1 = _box12;
        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
      }
      const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);
      const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);
      let c1StopTraversal;
      if (c1Intersection === CONTAINED) {
        const offset = getLeftOffset(c1);
        const end = getRightEndOffset(c1);
        const count = end - offset;
        c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);
      } else {
        c1StopTraversal = c1Intersection && shapecastTraverse(
          c1,
          geometry,
          intersectsBoundsFunc,
          intersectsRangeFunc,
          nodeScoreFunc,
          nodeIndexByteOffset,
          depth + 1
        );
      }
      if (c1StopTraversal)
        return true;
      box2 = _box22;
      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
      const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);
      const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);
      let c2StopTraversal;
      if (c2Intersection === CONTAINED) {
        const offset = getLeftOffset(c2);
        const end = getRightEndOffset(c2);
        const count = end - offset;
        c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);
      } else {
        c2StopTraversal = c2Intersection && shapecastTraverse(
          c2,
          geometry,
          intersectsBoundsFunc,
          intersectsRangeFunc,
          nodeScoreFunc,
          nodeIndexByteOffset,
          depth + 1
        );
      }
      if (c2StopTraversal)
        return true;
      return false;
    }
  }
}();
var intersectsGeometry = function() {
  const triangle = new ExtendedTriangle();
  const triangle2 = new ExtendedTriangle();
  const invertedMat = new Matrix4();
  const obb3 = new OrientedBox();
  const obb22 = new OrientedBox();
  return function intersectsGeometry2(nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null) {
    let nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;
    if (cachedObb === null) {
      if (!otherGeometry.boundingBox) {
        otherGeometry.computeBoundingBox();
      }
      obb3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
      cachedObb = obb3;
    }
    const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
    if (isLeaf) {
      const thisGeometry = geometry;
      const thisIndex = thisGeometry.index;
      const thisPos = thisGeometry.attributes.position;
      const index = otherGeometry.index;
      const pos = otherGeometry.attributes.position;
      const offset = OFFSET(nodeIndex32, uint32Array);
      const count = COUNT(nodeIndex16, uint16Array);
      invertedMat.copy(geometryToBvh).invert();
      if (otherGeometry.boundsTree) {
        arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb22);
        obb22.matrix.copy(invertedMat);
        obb22.needsUpdate = true;
        const res = otherGeometry.boundsTree.shapecast({
          intersectsBounds: (box) => obb22.intersectsBox(box),
          intersectsTriangle: (tri) => {
            tri.a.applyMatrix4(geometryToBvh);
            tri.b.applyMatrix4(geometryToBvh);
            tri.c.applyMatrix4(geometryToBvh);
            tri.needsUpdate = true;
            for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
              setTriangle(triangle2, i, thisIndex, thisPos);
              triangle2.needsUpdate = true;
              if (tri.intersectsTriangle(triangle2)) {
                return true;
              }
            }
            return false;
          }
        });
        return res;
      } else {
        for (let i = offset * 3, l = count + offset * 3; i < l; i += 3) {
          setTriangle(triangle, i, thisIndex, thisPos);
          triangle.a.applyMatrix4(invertedMat);
          triangle.b.applyMatrix4(invertedMat);
          triangle.c.applyMatrix4(invertedMat);
          triangle.needsUpdate = true;
          for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
            setTriangle(triangle2, i2, index, pos);
            triangle2.needsUpdate = true;
            if (triangle.intersectsTriangle(triangle2)) {
              return true;
            }
          }
        }
      }
    } else {
      const left = nodeIndex32 + 8;
      const right = uint32Array[nodeIndex32 + 6];
      arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);
      const leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry2(left, geometry, otherGeometry, geometryToBvh, cachedObb);
      if (leftIntersection)
        return true;
      arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);
      const rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry2(right, geometry, otherGeometry, geometryToBvh, cachedObb);
      if (rightIntersection)
        return true;
      return false;
    }
  };
}();
function intersectRay(nodeIndex32, array, ray2, target) {
  arrayToBox(nodeIndex32, array, boundingBox);
  return ray2.intersectBox(boundingBox, target);
}
var bufferStack = [];
var _prevBuffer;
var _float32Array;
var _uint16Array;
var _uint32Array;
function setBuffer(buffer) {
  if (_prevBuffer) {
    bufferStack.push(_prevBuffer);
  }
  _prevBuffer = buffer;
  _float32Array = new Float32Array(buffer);
  _uint16Array = new Uint16Array(buffer);
  _uint32Array = new Uint32Array(buffer);
}
function clearBuffer() {
  _prevBuffer = null;
  _float32Array = null;
  _uint16Array = null;
  _uint32Array = null;
  if (bufferStack.length) {
    setBuffer(bufferStack.pop());
  }
}

// node_modules/three-mesh-bvh/src/core/MeshBVH.js
var SKIP_GENERATION = Symbol("skip tree generation");
var aabb = new Box3();
var aabb2 = new Box3();
var tempMatrix = new Matrix4();
var obb = new OrientedBox();
var obb2 = new OrientedBox();
var temp = new Vector3();
var temp1 = new Vector3();
var temp2 = new Vector3();
var temp3 = new Vector3();
var temp4 = new Vector3();
var tempBox = new Box3();
var trianglePool = new PrimitivePool(() => new ExtendedTriangle());
var MeshBVH = class _MeshBVH {
  static serialize(bvh, options = {}) {
    if (options.isBufferGeometry) {
      console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.");
      return _MeshBVH.serialize(
        arguments[0],
        {
          cloneBuffers: arguments[2] === void 0 ? true : arguments[2]
        }
      );
    }
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute.array.slice()
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute.array
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    if (typeof options === "boolean") {
      console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.");
      return _MeshBVH.deserialize(
        arguments[0],
        arguments[1],
        {
          setIndex: arguments[2] === void 0 ? true : arguments[2]
        }
      );
    }
    options = {
      setIndex: true,
      ...options
    };
    const { index, roots } = data;
    const bvh = new _MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh._roots = roots;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      strategy: CENTER,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === "undefined") {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this._roots = null;
    if (!options[SKIP_GENERATION]) {
      this._roots = buildPackedTree(geometry, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    this.geometry = geometry;
  }
  refit(nodeIndices = null) {
    if (nodeIndices && Array.isArray(nodeIndices)) {
      nodeIndices = new Set(nodeIndices);
    }
    const geometry = this.geometry;
    const indexArr = geometry.index.array;
    const posAttr = geometry.attributes.position;
    let buffer, uint32Array, uint16Array, float32Array;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i = 0, l = roots.length; i < l; i++) {
      buffer = roots[i];
      uint32Array = new Uint32Array(buffer);
      uint16Array = new Uint16Array(buffer);
      float32Array = new Float32Array(buffer);
      _traverse(0, byteOffset);
      byteOffset += buffer.byteLength;
    }
    function _traverse(node32Index, byteOffset2, force = false) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        let minx = Infinity;
        let miny = Infinity;
        let minz = Infinity;
        let maxx = -Infinity;
        let maxy = -Infinity;
        let maxz = -Infinity;
        for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {
          const index = indexArr[i];
          const x = posAttr.getX(index);
          const y = posAttr.getY(index);
          const z = posAttr.getZ(index);
          if (x < minx)
            minx = x;
          if (x > maxx)
            maxx = x;
          if (y < miny)
            miny = y;
          if (y > maxy)
            maxy = y;
          if (z < minz)
            minz = z;
          if (z > maxz)
            maxz = z;
        }
        if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
          float32Array[node32Index + 0] = minx;
          float32Array[node32Index + 1] = miny;
          float32Array[node32Index + 2] = minz;
          float32Array[node32Index + 3] = maxx;
          float32Array[node32Index + 4] = maxy;
          float32Array[node32Index + 5] = maxz;
          return true;
        } else {
          return false;
        }
      } else {
        const left = node32Index + 8;
        const right = uint32Array[node32Index + 6];
        const offsetLeft = left + byteOffset2;
        const offsetRight = right + byteOffset2;
        let forceChildren = force;
        let includesLeft = false;
        let includesRight = false;
        if (nodeIndices) {
          if (!forceChildren) {
            includesLeft = nodeIndices.has(offsetLeft);
            includesRight = nodeIndices.has(offsetRight);
            forceChildren = !includesLeft && !includesRight;
          }
        } else {
          includesLeft = true;
          includesRight = true;
        }
        const traverseLeft = forceChildren || includesLeft;
        const traverseRight = forceChildren || includesRight;
        let leftChange = false;
        if (traverseLeft) {
          leftChange = _traverse(left, byteOffset2, forceChildren);
        }
        let rightChange = false;
        if (traverseRight) {
          rightChange = _traverse(right, byteOffset2, forceChildren);
        }
        const didChange = leftChange || rightChange;
        if (didChange) {
          for (let i = 0; i < 3; i++) {
            const lefti = left + i;
            const righti = right + i;
            const minLeftValue = float32Array[lefti];
            const maxLeftValue = float32Array[lefti + 3];
            const minRightValue = float32Array[righti];
            const maxRightValue = float32Array[righti + 3];
            float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
            float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
          }
        }
        return didChange;
      }
    }
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array = new Uint32Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    _traverse(0);
    function _traverse(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array[node32Index + 6];
        const splitAxis = uint32Array[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse(left, depth + 1);
          _traverse(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray2, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const startCount = intersects.length;
      setBuffer(roots[i]);
      raycast(0, geometry, materialSide, ray2, intersects);
      clearBuffer();
      if (isArrayMaterial) {
        const materialIndex = groups[i].materialIndex;
        for (let j = startCount, jl = intersects.length; j < jl; j++) {
          intersects[j].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects;
  }
  raycastFirst(ray2, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      setBuffer(roots[i]);
      const result = raycastFirst(0, geometry, materialSide, ray2);
      clearBuffer();
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    const geometry = this.geometry;
    let result = false;
    for (const root of this._roots) {
      setBuffer(root);
      result = intersectsGeometry(0, geometry, otherGeometry, geomToMesh);
      clearBuffer();
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {
    const geometry = this.geometry;
    if (callbacks instanceof Function) {
      if (_intersectsTriangleFunc) {
        const originalTriangleFunc = _intersectsTriangleFunc;
        _intersectsTriangleFunc = (tri, index, contained, depth) => {
          const i3 = index * 3;
          return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);
        };
      }
      callbacks = {
        boundsTraverseOrder: _orderNodesFunc,
        intersectsBounds: callbacks,
        intersectsTriangle: _intersectsTriangleFunc,
        intersectsRange: null
      };
      console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.");
    }
    const triangle = trianglePool.getPrimitive();
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    for (const root of this._roots) {
      setBuffer(root);
      result = shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      clearBuffer();
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    trianglePool.releasePrimitive(triangle);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const indexAttr = this.geometry.index;
    const positionAttr = this.geometry.attributes.position;
    const otherIndexAttr = otherBvh.geometry.index;
    const otherPositionAttr = otherBvh.geometry.attributes.position;
    tempMatrix.copy(matrixToLocal).invert();
    const triangle = trianglePool.getPrimitive();
    const triangle2 = trianglePool.getPrimitive();
    if (intersectsTriangles) {
      let iterateOverDoubleTriangles = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);
          triangle2.a.applyMatrix4(matrixToLocal);
          triangle2.b.applyMatrix4(matrixToLocal);
          triangle2.c.applyMatrix4(matrixToLocal);
          triangle2.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            setTriangle(triangle, i1 * 3, indexAttr, positionAttr);
            triangle.needsUpdate = true;
            if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    otherBvh.getBoundingBox(aabb2);
    aabb2.applyMatrix4(matrixToLocal);
    const result = this.shapecast({
      intersectsBounds: (box) => aabb2.intersectsBox(box),
      intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box) => {
        aabb.copy(box);
        aabb.applyMatrix4(tempMatrix);
        return otherBvh.shapecast({
          intersectsBounds: (box2) => aabb.intersectsBox(box2),
          intersectsRange: (offset2, count2, contained2, depth2, nodeIndex2) => {
            return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);
          }
        });
      }
    });
    trianglePool.releasePrimitive(triangle);
    trianglePool.releasePrimitive(triangle2);
    return result;
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb.set(box.min, box.max, boxToMesh);
    obb.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb.intersectsBox(box2),
        intersectsTriangle: (tri) => obb.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    obb.needsUpdate = true;
    const geometry = this.geometry;
    const pos = geometry.attributes.position;
    const index = geometry.index;
    const otherPos = otherGeometry.attributes.position;
    const otherIndex = otherGeometry.index;
    const triangle = trianglePool.getPrimitive();
    const triangle2 = trianglePool.getPrimitive();
    let tempTarget1 = temp1;
    let tempTargetDest1 = temp2;
    let tempTarget2 = null;
    let tempTargetDest2 = null;
    if (target2) {
      tempTarget2 = temp3;
      tempTargetDest2 = temp4;
    }
    let closestDistance = Infinity;
    let closestDistanceTriIndex = null;
    let closestDistanceOtherTriIndex = null;
    tempMatrix.copy(geometryToBvh).invert();
    obb2.matrix.copy(tempMatrix);
    this.shapecast(
      {
        boundsTraverseOrder: (box) => {
          return obb.distanceToBox(box);
        },
        intersectsBounds: (box, isLeaf, score) => {
          if (score < closestDistance && score < maxThreshold) {
            if (isLeaf) {
              obb2.min.copy(box.min);
              obb2.max.copy(box.max);
              obb2.needsUpdate = true;
            }
            return true;
          }
          return false;
        },
        intersectsRange: (offset, count) => {
          if (otherGeometry.boundsTree) {
            return otherGeometry.boundsTree.shapecast({
              boundsTraverseOrder: (box) => {
                return obb2.distanceToBox(box);
              },
              intersectsBounds: (box, isLeaf, score) => {
                return score < closestDistance && score < maxThreshold;
              },
              intersectsRange: (otherOffset, otherCount) => {
                for (let i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {
                  setTriangle(triangle2, i2, otherIndex, otherPos);
                  triangle2.a.applyMatrix4(geometryToBvh);
                  triangle2.b.applyMatrix4(geometryToBvh);
                  triangle2.c.applyMatrix4(geometryToBvh);
                  triangle2.needsUpdate = true;
                  for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {
                    setTriangle(triangle, i, index, pos);
                    triangle.needsUpdate = true;
                    const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);
                    if (dist < closestDistance) {
                      tempTargetDest1.copy(tempTarget1);
                      if (tempTargetDest2) {
                        tempTargetDest2.copy(tempTarget2);
                      }
                      closestDistance = dist;
                      closestDistanceTriIndex = i / 3;
                      closestDistanceOtherTriIndex = i2 / 3;
                    }
                    if (dist < minThreshold) {
                      return true;
                    }
                  }
                }
              }
            });
          } else {
            const triCount = otherIndex ? otherIndex.count : otherPos.count;
            for (let i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {
              setTriangle(triangle2, i2, otherIndex, otherPos);
              triangle2.a.applyMatrix4(geometryToBvh);
              triangle2.b.applyMatrix4(geometryToBvh);
              triangle2.c.applyMatrix4(geometryToBvh);
              triangle2.needsUpdate = true;
              for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {
                setTriangle(triangle, i, index, pos);
                triangle.needsUpdate = true;
                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);
                if (dist < closestDistance) {
                  tempTargetDest1.copy(tempTarget1);
                  if (tempTargetDest2) {
                    tempTargetDest2.copy(tempTarget2);
                  }
                  closestDistance = dist;
                  closestDistanceTriIndex = i / 3;
                  closestDistanceOtherTriIndex = i2 / 3;
                }
                if (dist < minThreshold) {
                  return true;
                }
              }
            }
          }
        }
      }
    );
    trianglePool.releasePrimitive(triangle);
    trianglePool.releasePrimitive(triangle2);
    if (closestDistance === Infinity)
      return null;
    if (!target1.point)
      target1.point = tempTargetDest1.clone();
    else
      target1.point.copy(tempTargetDest1);
    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
    if (target2) {
      if (!target2.point)
        target2.point = tempTargetDest2.clone();
      else
        target2.point.copy(tempTargetDest2);
      target2.point.applyMatrix4(tempMatrix);
      tempTargetDest1.applyMatrix4(tempMatrix);
      target2.distance = tempTargetDest1.sub(target2.point).length();
      target2.faceIndex = closestDistanceOtherTriIndex;
    }
    return target1;
  }
  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
    const minThresholdSq = minThreshold * minThreshold;
    const maxThresholdSq = maxThreshold * maxThreshold;
    let closestDistanceSq = Infinity;
    let closestDistanceTriIndex = null;
    this.shapecast(
      {
        boundsTraverseOrder: (box) => {
          temp.copy(point).clamp(box.min, box.max);
          return temp.distanceToSquared(point);
        },
        intersectsBounds: (box, isLeaf, score) => {
          return score < closestDistanceSq && score < maxThresholdSq;
        },
        intersectsTriangle: (tri, triIndex) => {
          tri.closestPointToPoint(point, temp);
          const distSq = point.distanceToSquared(temp);
          if (distSq < closestDistanceSq) {
            temp1.copy(temp);
            closestDistanceSq = distSq;
            closestDistanceTriIndex = triIndex;
          }
          if (distSq < minThresholdSq) {
            return true;
          } else {
            return false;
          }
        }
      }
    );
    if (closestDistanceSq === Infinity)
      return null;
    const closestDistance = Math.sqrt(closestDistanceSq);
    if (!target.point)
      target.point = temp1.clone();
    else
      target.point.copy(temp1);
    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;
    return target;
  }
  getBoundingBox(target) {
    target.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target.union(tempBox);
    });
    return target;
  }
};

// node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js
var boundingBox2 = new Box3();

// node_modules/three-mesh-bvh/src/debug/Debug.js
var _box1 = new Box3();
var _box2 = new Box3();
var _vec = new Vector3();

// node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js
var ray = new Ray();
var tmpInverseMatrix = new Matrix4();
var origMeshRaycastFunc = Mesh.prototype.raycast;

// node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js
var _positionVector = new Vector3();
var _normalVector = new Vector3();
var _tangentVector = new Vector3();
var _tangentVector4 = new Vector4();
var _morphVector = new Vector3();
var _temp = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _matrix = new Matrix4();
var _boneMatrix = new Matrix4();

// node_modules/three-bvh-csg/src/utils/hashUtils.js
var HASH_MULTIPLIER = (1 + 1e-7) * 1e6;
function hashNumber(v) {
  return ~~(v * HASH_MULTIPLIER);
}
function hashVertex(v) {
  return `${hashNumber(v.x)},${hashNumber(v.y)},${hashNumber(v.z)}`;
}

// node_modules/three-bvh-csg/src/core/HalfEdgeMap.js
var _vertices = [new Vector3(), new Vector3(), new Vector3()];
var HalfEdgeMap = class {
  constructor(geometry = null) {
    this.data = null;
    this.unmatchedEdges = null;
    this.matchedEdges = null;
    this.useDrawRange = true;
    if (geometry) {
      this.updateFrom(geometry);
    }
  }
  getSiblingTriangleIndex(triIndex, edgeIndex) {
    const otherIndex = this.data[triIndex * 3 + edgeIndex];
    return otherIndex === -1 ? -1 : ~~(otherIndex / 3);
  }
  getSiblingEdgeIndex(triIndex, edgeIndex) {
    const otherIndex = this.data[triIndex * 3 + edgeIndex];
    return otherIndex === -1 ? -1 : otherIndex % 3;
  }
  updateFrom(geometry) {
    const map = /* @__PURE__ */ new Map();
    const { attributes } = geometry;
    const indexAttr = geometry.index;
    const posAttr = attributes.position;
    let triCount = indexAttr ? indexAttr.count / 3 : posAttr.count / 3;
    const maxTriCount = triCount;
    let offset = 0;
    if (this.useDrawRange) {
      offset = geometry.drawRange.start;
      if (geometry.drawRange.count !== Infinity) {
        triCount = ~~(geometry.drawRange.count / 3);
      }
    }
    let data = this.data;
    if (!data || data.length < 3 * maxTriCount) {
      data = new Int32Array(3 * maxTriCount);
    }
    data.fill(-1);
    let unmatchedEdges = 0;
    let matchedEdges = 0;
    for (let i = 0; i < triCount; i++) {
      const i3 = 3 * i + offset;
      for (let e = 0; e < 3; e++) {
        let i0 = i3 + e;
        if (indexAttr) {
          i0 = indexAttr.getX(i0);
        }
        _vertices[e].fromBufferAttribute(posAttr, i0);
      }
      for (let e = 0; e < 3; e++) {
        const nextE = (e + 1) % 3;
        const _vec0 = _vertices[e];
        const _vec1 = _vertices[nextE];
        const vh0 = hashVertex(_vec0);
        const vh1 = hashVertex(_vec1);
        const reverseHash = `${vh1}_${vh0}`;
        if (map.has(reverseHash)) {
          const otherIndex = map.get(reverseHash);
          data[i3 + e] = otherIndex;
          data[otherIndex] = i3 + e;
          map.delete(reverseHash);
          unmatchedEdges--;
          matchedEdges++;
        } else {
          const hash = `${vh0}_${vh1}`;
          map.set(hash, i3 + e);
          unmatchedEdges++;
        }
      }
    }
    this.matchedEdges = matchedEdges;
    this.unmatchedEdges = unmatchedEdges;
    this.data = data;
  }
};

// node_modules/three-bvh-csg/src/core/utils.js
function areSharedArrayBuffersSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}
function convertToSharedArrayBuffer(array) {
  if (array.buffer instanceof SharedArrayBuffer) {
    return array;
  }
  const cons = array.constructor;
  const buffer = array.buffer;
  const sharedBuffer = new SharedArrayBuffer(buffer.byteLength);
  const uintArray = new Uint8Array(buffer);
  const sharedUintArray = new Uint8Array(sharedBuffer);
  sharedUintArray.set(uintArray, 0);
  return new cons(sharedBuffer);
}

// node_modules/three-bvh-csg/src/core/Brush.js
var Brush = class extends Mesh {
  constructor(...args) {
    super(...args);
    this.isBrush = true;
    this._previousMatrix = new Matrix4();
    this._previousMatrix.elements.fill(0);
  }
  markUpdated() {
    this._previousMatrix.copy(this.matrix);
  }
  isDirty() {
    const { matrix, _previousMatrix } = this;
    const el1 = matrix.elements;
    const el2 = _previousMatrix.elements;
    for (let i = 0; i < 16; i++) {
      if (el1[i] !== el2[i]) {
        return true;
      }
    }
    return false;
  }
  prepareGeometry() {
    const geometry = this.geometry;
    const attributes = geometry.attributes;
    if (areSharedArrayBuffersSupported()) {
      for (const key in attributes) {
        const attribute = attributes[key];
        if (attribute.isInterleavedBufferAttribute) {
          throw new Error("Brush: InterleavedBufferAttributes are not supported.");
        }
        attribute.array = convertToSharedArrayBuffer(attribute.array);
      }
    }
    if (!geometry.boundsTree) {
      geometry.boundsTree = new MeshBVH(geometry, { maxLeafTris: 3 });
      if (geometry.halfEdges) {
        geometry.halfEdges.updateFrom(geometry);
      }
    }
    if (!geometry.halfEdges) {
      geometry.halfEdges = new HalfEdgeMap(geometry);
    }
    if (!geometry.groupIndices) {
      const triCount = geometry.index.count / 3;
      const array = new Uint16Array(triCount);
      const groups = geometry.groups;
      for (let i = 0, l = groups.length; i < l; i++) {
        const { start, count } = groups[i];
        for (let g = start / 3, lg = (start + count) / 3; g < lg; g++) {
          array[g] = i;
        }
      }
      geometry.groupIndices = array;
    }
  }
  disposeCacheData() {
    const { geometry } = this;
    geometry.halfEdges = null;
    geometry.boundsTree = null;
    geometry.groupIndices = null;
  }
};

// node_modules/three-bvh-csg/src/core/IntersectionMap.js
var IntersectionMap = class {
  constructor() {
    this.intersectionSet = {};
    this.ids = [];
  }
  add(id, intersectionId) {
    const { intersectionSet, ids } = this;
    if (!intersectionSet[id]) {
      intersectionSet[id] = [];
      ids.push(id);
    }
    intersectionSet[id].push(intersectionId);
  }
};

// node_modules/three-bvh-csg/src/core/constants.js
var ADDITION = 0;
var SUBTRACTION = 1;
var DIFFERENCE = 3;
var INTERSECTION = 4;

// node_modules/three-bvh-csg/src/core/operationsUtils.js
var _ray = new Ray();
var _matrix2 = new Matrix4();
var _tri = new Triangle();
var _vec3 = new Vector3();
var _vec4a = new Vector4();
var _vec4b = new Vector4();
var _vec4c = new Vector4();
var _vec4_0 = new Vector4();
var _vec4_1 = new Vector4();
var _vec4_2 = new Vector4();
var _edge = new Line3();
var _normal = new Vector3();
var JITTER_EPSILON = 1e-8;
var OFFSET_EPSILON = 1e-15;
var BACK_SIDE = -1;
var FRONT_SIDE = 1;
var COPLANAR_OPPOSITE = -2;
var COPLANAR_ALIGNED = 2;
var INVERT_TRI = 0;
var ADD_TRI = 1;
var SKIP_TRI = 2;
var _debugContext = null;
function setDebugContext(debugData) {
  _debugContext = debugData;
}
function getHitSide(tri, bvh) {
  function rand() {
    return Math.random() - 0.5;
  }
  tri.getNormal(_normal);
  _ray.direction.copy(_normal);
  tri.getMidpoint(_ray.origin);
  const total = 3;
  let count = 0;
  let minDistance = Infinity;
  for (let i = 0; i < total; i++) {
    _ray.direction.x += rand() * JITTER_EPSILON;
    _ray.direction.y += rand() * JITTER_EPSILON;
    _ray.direction.z += rand() * JITTER_EPSILON;
    _ray.direction.multiplyScalar(-1);
    const hit = bvh.raycastFirst(_ray, DoubleSide);
    let hitBackSide = Boolean(hit && _ray.direction.dot(hit.face.normal) > 0);
    if (hitBackSide) {
      count++;
    }
    if (hit !== null) {
      minDistance = Math.min(minDistance, hit.distance);
    }
    if (minDistance <= OFFSET_EPSILON) {
      return hit.face.normal.dot(_normal) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;
    }
    if (count / total > 0.5 || (i - count + 1) / total > 0.5) {
      break;
    }
  }
  return count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;
}
function collectIntersectingTriangles(a, b) {
  const aIntersections = new IntersectionMap();
  const bIntersections = new IntersectionMap();
  _matrix2.copy(a.matrixWorld).invert().multiply(b.matrixWorld);
  a.geometry.boundsTree.bvhcast(b.geometry.boundsTree, _matrix2, {
    intersectsTriangles(triangleA, triangleB, ia, ib) {
      if (triangleA.intersectsTriangle(triangleB, _edge, true)) {
        if (_edge.distanceSq() === 0 && triangleA.plane.normal.dot(triangleB.plane.normal) < 1 - 1e-10) {
          return false;
        }
        aIntersections.add(ia, ib);
        bIntersections.add(ib, ia);
        if (_debugContext) {
          _debugContext.addEdge(_edge);
          _debugContext.addIntersectingTriangles(ia, triangleA, ib, triangleB);
        }
      }
      return false;
    }
  });
  return { aIntersections, bIntersections };
}
function appendAttributeFromTriangle(triIndex, baryCoordTri, geometry, matrixWorld, normalMatrix, attributeInfo, invert = false) {
  const attributes = geometry.attributes;
  const indexAttr = geometry.index;
  const i3 = triIndex * 3;
  const i0 = indexAttr.getX(i3 + 0);
  const i1 = indexAttr.getX(i3 + 1);
  const i2 = indexAttr.getX(i3 + 2);
  for (const key in attributeInfo) {
    const attr = attributes[key];
    const arr = attributeInfo[key];
    if (!(key in attributes)) {
      throw new Error(`CSG Operations: Attribute ${key} not available on geometry.`);
    }
    const itemSize = attr.itemSize;
    if (key === "position") {
      _tri.a.fromBufferAttribute(attr, i0).applyMatrix4(matrixWorld);
      _tri.b.fromBufferAttribute(attr, i1).applyMatrix4(matrixWorld);
      _tri.c.fromBufferAttribute(attr, i2).applyMatrix4(matrixWorld);
      pushBarycoordInterpolatedValues(_tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert);
    } else if (key === "normal") {
      _tri.a.fromBufferAttribute(attr, i0).applyNormalMatrix(normalMatrix);
      _tri.b.fromBufferAttribute(attr, i1).applyNormalMatrix(normalMatrix);
      _tri.c.fromBufferAttribute(attr, i2).applyNormalMatrix(normalMatrix);
      if (invert) {
        _tri.a.multiplyScalar(-1);
        _tri.b.multiplyScalar(-1);
        _tri.c.multiplyScalar(-1);
      }
      pushBarycoordInterpolatedValues(_tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true);
    } else {
      _vec4a.fromBufferAttribute(attr, i0);
      _vec4b.fromBufferAttribute(attr, i1);
      _vec4c.fromBufferAttribute(attr, i2);
      pushBarycoordInterpolatedValues(_vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert);
    }
  }
}
function appendAttributesFromIndices(i0, i1, i2, attributes, matrixWorld, normalMatrix, attributeInfo, invert = false) {
  appendAttributeFromIndex(i0, attributes, matrixWorld, normalMatrix, attributeInfo, invert);
  appendAttributeFromIndex(invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeInfo, invert);
  appendAttributeFromIndex(invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeInfo, invert);
}
function getOperationAction(operation, hitSide, invert = false) {
  switch (operation) {
    case ADDITION:
      if (hitSide === FRONT_SIDE || hitSide === COPLANAR_ALIGNED && !invert) {
        return ADD_TRI;
      }
      break;
    case SUBTRACTION:
      if (invert) {
        if (hitSide === BACK_SIDE) {
          return INVERT_TRI;
        }
      } else {
        if (hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE) {
          return ADD_TRI;
        }
      }
      break;
    case DIFFERENCE:
      if (hitSide === BACK_SIDE) {
        return INVERT_TRI;
      } else if (hitSide === FRONT_SIDE) {
        return ADD_TRI;
      }
      break;
    case INTERSECTION:
      if (hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED && !invert) {
        return ADD_TRI;
      }
      break;
    default:
      throw new Error(`Unrecognized CSG operation enum "${operation}".`);
  }
  return SKIP_TRI;
}
function pushBarycoordInterpolatedValues(v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false) {
  const addValues = (v) => {
    attrArr.push(v.x);
    if (itemSize > 1)
      attrArr.push(v.y);
    if (itemSize > 2)
      attrArr.push(v.z);
    if (itemSize > 3)
      attrArr.push(v.w);
  };
  _vec4_0.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.a.x).addScaledVector(v1, baryCoordTri.a.y).addScaledVector(v2, baryCoordTri.a.z);
  _vec4_1.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.b.x).addScaledVector(v1, baryCoordTri.b.y).addScaledVector(v2, baryCoordTri.b.z);
  _vec4_2.set(0, 0, 0, 0).addScaledVector(v0, baryCoordTri.c.x).addScaledVector(v1, baryCoordTri.c.y).addScaledVector(v2, baryCoordTri.c.z);
  if (normalize) {
    _vec4_0.normalize();
    _vec4_1.normalize();
    _vec4_2.normalize();
  }
  addValues(_vec4_0);
  if (invert) {
    addValues(_vec4_2);
    addValues(_vec4_1);
  } else {
    addValues(_vec4_1);
    addValues(_vec4_2);
  }
}
function appendAttributeFromIndex(index, attributes, matrixWorld, normalMatrix, attributeInfo, invert = false) {
  for (const key in attributeInfo) {
    const attr = attributes[key];
    const arr = attributeInfo[key];
    if (!(key in attributes)) {
      throw new Error(`CSG Operations: Attribute ${key} no available on geometry.`);
    }
    const itemSize = attr.itemSize;
    if (key === "position") {
      _vec3.fromBufferAttribute(attr, index).applyMatrix4(matrixWorld);
      arr.push(_vec3.x, _vec3.y, _vec3.z);
    } else if (key === "normal") {
      _vec3.fromBufferAttribute(attr, index).applyNormalMatrix(normalMatrix);
      if (invert) {
        _vec3.multiplyScalar(-1);
      }
      arr.push(_vec3.x, _vec3.y, _vec3.z);
    } else {
      arr.push(attr.getX(index));
      if (itemSize > 1)
        arr.push(attr.getY(index));
      if (itemSize > 2)
        arr.push(attr.getZ(index));
      if (itemSize > 3)
        arr.push(attr.getW(index));
    }
  }
}

// node_modules/three-bvh-csg/src/core/TriangleSplitter.js
var EPSILON = 1e-14;
var COPLANAR_EPSILON = 1e-10;
var _edge2 = new Line3();
var _foundEdge = new Line3();
var _vec2 = new Vector3();
var _planeNormal = new Vector3();
var _plane = new Plane();
var _exTriangle = new ExtendedTriangle();
function isTriDegenerate(tri) {
  return tri.a.distanceToSquared(tri.b) < EPSILON || tri.a.distanceToSquared(tri.c) < EPSILON || tri.b.distanceToSquared(tri.c) < EPSILON;
}
var TrianglePool = class {
  constructor() {
    this._pool = [];
    this._index = 0;
  }
  getTriangle() {
    if (this._index >= this._pool.length) {
      this._pool.push(new Triangle());
    }
    return this._pool[this._index++];
  }
  clear() {
    this._index = 0;
  }
  reset() {
    this._pool.length = 0;
    this._index = 0;
  }
};
var TriangleSplitter = class {
  constructor() {
    this.trianglePool = new TrianglePool();
    this.triangles = [];
    this.normal = new Vector3();
  }
  // initialize the class with a triangle
  initialize(tri) {
    const { triangles, trianglePool: trianglePool2, normal } = this;
    triangles.length = 0;
    trianglePool2.clear();
    if (Array.isArray(tri)) {
      for (let i = 0, l = tri.length; i < l; i++) {
        const t = tri[i];
        if (i === 0) {
          t.getNormal(normal);
        } else if (Math.abs(1 - t.getNormal(_vec2).dot(normal)) > EPSILON) {
          throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");
        }
        const poolTri = trianglePool2.getTriangle();
        poolTri.copy(t);
        triangles.push(poolTri);
      }
    } else {
      tri.getNormal(normal);
      const poolTri = trianglePool2.getTriangle();
      poolTri.copy(tri);
      triangles.push(poolTri);
    }
  }
  // Split the current set of triangles by passing a single triangle in. If the triangle is
  // coplanar it will attempt to split by the triangle edge planes
  splitByTriangle(triangle) {
    const { normal, triangles } = this;
    triangle.getPlane(_plane);
    if (Math.abs(1 - Math.abs(_plane.normal.dot(normal))) < COPLANAR_EPSILON) {
      const arr = [triangle.a, triangle.b, triangle.c];
      for (let i = 0; i < 3; i++) {
        const nexti = (i + 1) % 3;
        const v0 = arr[i];
        const v1 = arr[nexti];
        _vec2.subVectors(v1, v0).normalize();
        _planeNormal.crossVectors(normal, _vec2);
        _plane.setFromNormalAndCoplanarPoint(_planeNormal, v0);
        this.splitByPlane(_plane, triangle, i);
      }
      for (let i = 0, l = triangles.length; i < l; i++) {
        const t = triangles[i];
        t.coplanarCount = 0;
      }
    } else {
      this.splitByPlane(_plane, triangle);
    }
  }
  // Split the triangles by the given plan. If a triangle is provided then we ensure we
  // intersect the triangle before splitting the plane
  splitByPlane(plane, triangle = null, coplanarIndex = -1) {
    const { triangles, trianglePool: trianglePool2 } = this;
    let splittingTriangle = null;
    if (triangle !== null) {
      splittingTriangle = _exTriangle;
      splittingTriangle.copy(triangle);
      splittingTriangle.needsUpdate = true;
    }
    for (let i = 0, l = triangles.length; i < l; i++) {
      const tri = triangles[i];
      const { a, b, c } = tri;
      if (splittingTriangle) {
        if (!splittingTriangle.intersectsTriangle(tri, _edge2, true)) {
          continue;
        }
      }
      let intersects = 0;
      let vertexSplitEnd = -1;
      let positiveSide = 0;
      let coplanarEdge = false;
      const arr = [a, b, c];
      for (let t = 0; t < 3; t++) {
        const tNext = (t + 1) % 3;
        _edge2.start.copy(arr[t]);
        _edge2.end.copy(arr[tNext]);
        const startDist = plane.distanceToPoint(_edge2.start);
        const endDist = plane.distanceToPoint(_edge2.end);
        if (Math.abs(startDist) < COPLANAR_EPSILON && Math.abs(endDist) < COPLANAR_EPSILON) {
          coplanarEdge = true;
          break;
        }
        if (Math.abs(startDist) < COPLANAR_EPSILON) {
          continue;
        }
        if (startDist > 0) {
          positiveSide++;
        }
        let didIntersect = !!plane.intersectLine(_edge2, _vec2);
        if (!didIntersect && Math.abs(endDist) < COPLANAR_EPSILON) {
          _vec2.copy(_edge2.end);
          didIntersect = true;
        }
        if (didIntersect && !(_vec2.distanceTo(_edge2.start) < EPSILON)) {
          if (_vec2.distanceTo(_edge2.end) < EPSILON) {
            vertexSplitEnd = t;
          }
          if (intersects === 0) {
            _foundEdge.start.copy(_vec2);
          } else {
            _foundEdge.end.copy(_vec2);
          }
          intersects++;
        }
      }
      if (coplanarEdge) {
        continue;
      }
      if (intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON) {
        if (vertexSplitEnd !== -1) {
          vertexSplitEnd = (vertexSplitEnd + 1) % 3;
          let otherVert1 = 0;
          if (otherVert1 === vertexSplitEnd)
            otherVert1 = (otherVert1 + 1) % 3;
          let otherVert2 = otherVert1 + 1;
          if (otherVert2 === vertexSplitEnd)
            otherVert2 = (otherVert2 + 1) % 3;
          const nextTri = trianglePool2.getTriangle();
          nextTri.a.copy(arr[otherVert2]);
          nextTri.b.copy(_foundEdge.end);
          nextTri.c.copy(_foundEdge.start);
          if (!isTriDegenerate(nextTri)) {
            triangles.push(nextTri);
          }
          tri.a.copy(arr[otherVert1]);
          tri.b.copy(_foundEdge.start);
          tri.c.copy(_foundEdge.end);
          if (isTriDegenerate(tri)) {
            triangles.splice(i, 1);
            i--;
            l--;
          }
        } else {
          const singleVert = arr.findIndex((v) => {
            if (positiveSide >= 2) {
              return plane.distanceToPoint(v) < 0;
            } else {
              return plane.distanceToPoint(v) > 0;
            }
          });
          if (singleVert === 0) {
            let tmp = _foundEdge.start;
            _foundEdge.start = _foundEdge.end;
            _foundEdge.end = tmp;
          } else if (singleVert === -1) {
            continue;
          }
          const nextVert1 = (singleVert + 1) % 3;
          const nextVert2 = (singleVert + 2) % 3;
          const nextTri1 = trianglePool2.getTriangle();
          const nextTri2 = trianglePool2.getTriangle();
          if (arr[nextVert1].distanceToSquared(_foundEdge.start) < arr[nextVert2].distanceToSquared(_foundEdge.end)) {
            nextTri1.a.copy(arr[nextVert1]);
            nextTri1.b.copy(_foundEdge.start);
            nextTri1.c.copy(_foundEdge.end);
            nextTri2.a.copy(arr[nextVert1]);
            nextTri2.b.copy(arr[nextVert2]);
            nextTri2.c.copy(_foundEdge.start);
          } else {
            nextTri1.a.copy(arr[nextVert2]);
            nextTri1.b.copy(_foundEdge.start);
            nextTri1.c.copy(_foundEdge.end);
            nextTri2.a.copy(arr[nextVert1]);
            nextTri2.b.copy(arr[nextVert2]);
            nextTri2.c.copy(_foundEdge.end);
          }
          tri.a.copy(arr[singleVert]);
          tri.b.copy(_foundEdge.end);
          tri.c.copy(_foundEdge.start);
          if (!isTriDegenerate(nextTri1)) {
            triangles.push(nextTri1);
          }
          if (!isTriDegenerate(nextTri2)) {
            triangles.push(nextTri2);
          }
          if (isTriDegenerate(tri)) {
            triangles.splice(i, 1);
            i--;
            l--;
          }
        }
      } else if (intersects === 3) {
        console.warn("TriangleClipper: Coplanar clip not handled");
      }
    }
  }
  reset() {
    this.triangles.length = 0;
  }
};

// node_modules/three-bvh-csg/src/core/TypeBackedArray.js
var TypeBackedArray = class {
  constructor(type, initialSize = 500) {
    const bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;
    this.expansionFactor = 1.5;
    this.type = type;
    this.array = new type(new bufferType(initialSize * type.BYTES_PER_ELEMENT));
    this.length = 0;
  }
  expand(size = null) {
    const { type, array, expansionFactor } = this;
    if (size === null) {
      size = ~~(array.length * expansionFactor);
    }
    const newArray = new type(size);
    newArray.set(array, 0);
    this.array = newArray;
  }
  push(...args) {
    let { array, length } = this;
    if (length + args.length > array.length) {
      this.expand();
      array = this.array;
    }
    for (let i = 0, l = args.length; i < l; i++) {
      array[length + i] = args[i];
    }
    this.length += args.length;
  }
  clear() {
    this.length = 0;
  }
};

// node_modules/three-bvh-csg/src/core/TypedAttributeData.js
var TypedAttributeData = class {
  constructor() {
    this.groupAttributes = [{}];
    this.groupCount = 0;
  }
  getType(name) {
    return this.groupAttributes[0][name].type;
  }
  getTotalLength(name) {
    const { groupCount, groupAttributes } = this;
    let length = 0;
    for (let i = 0; i < groupCount; i++) {
      const attrSet = groupAttributes[i];
      length += attrSet[name].length;
    }
    return length;
  }
  getGroupSet(index = 0) {
    const { groupAttributes } = this;
    if (groupAttributes[index]) {
      this.groupCount = Math.max(this.groupCount, index + 1);
      return groupAttributes[index];
    }
    const rootAttrSet = groupAttributes[0];
    this.groupCount = Math.max(this.groupCount, index + 1);
    while (index >= groupAttributes.length) {
      const newAttrSet = {};
      groupAttributes.push(newAttrSet);
      for (const key in rootAttrSet) {
        newAttrSet[key] = new TypeBackedArray(rootAttrSet[key].type);
      }
    }
    return groupAttributes[index];
  }
  getGroupArray(name, index = 0) {
    const { groupAttributes } = this;
    const rootAttrSet = groupAttributes[0];
    const referenceAttr = rootAttrSet[name];
    if (!referenceAttr) {
      throw new Error(`TypedAttributeData: Attribute with "${name}" has not been initialized`);
    }
    return this.getGroupSet(index)[name];
  }
  // initializes an attribute array with the given name, type, and size
  initializeArray(name, type) {
    const { groupAttributes } = this;
    const rootSet = groupAttributes[0];
    const referenceAttr = rootSet[name];
    if (referenceAttr) {
      if (referenceAttr.type !== type) {
        throw new Error(`TypedAttributeData: Array ${name} already initialized with a different type.`);
      }
    } else {
      for (let i = 0, l = groupAttributes.length; i < l; i++) {
        groupAttributes[i][name] = new TypeBackedArray(type);
      }
    }
  }
  clear() {
    this.groupCount = 0;
    const { groupAttributes } = this;
    groupAttributes.forEach((attrSet) => {
      for (const key in attrSet) {
        attrSet[key].clear();
      }
    });
  }
  delete(key) {
    this.groupAttributes.forEach((attrSet) => {
      delete attrSet[key];
    });
  }
  reset() {
    this.groupAttributes = [];
  }
};

// node_modules/three-bvh-csg/src/core/OperationDebugData.js
var TriangleIntersectData = class {
  constructor(tri) {
    this.triangle = new Triangle().copy(tri);
    this.intersects = {};
  }
  addTriangle(index, tri) {
    this.intersects[index] = new Triangle().copy(tri);
  }
  getIntersectArray() {
    const array = [];
    const { intersects } = this;
    for (const key in intersects) {
      array.push(intersects[key]);
    }
    return array;
  }
};
var TriangleIntersectionSets = class {
  constructor() {
    this.data = {};
  }
  addTriangleIntersection(ia, triA, ib, triB) {
    const { data } = this;
    if (!data[ia]) {
      data[ia] = new TriangleIntersectData(triA);
    }
    data[ia].addTriangle(ib, triB);
  }
  getTrianglesAsArray(id = null) {
    const { data } = this;
    const arr = [];
    if (id !== null) {
      if (id in data) {
        arr.push(data[id].triangle);
      }
    } else {
      for (const key in data) {
        arr.push(data[key].triangle);
      }
    }
    return arr;
  }
  getTriangleIndices() {
    return Object.keys(this.data).map((i) => parseInt(i));
  }
  getIntersectionIndices(id) {
    const { data } = this;
    if (!data[id]) {
      return [];
    } else {
      return Object.keys(data[id].intersects).map((i) => parseInt(i));
    }
  }
  getIntersectionsAsArray(id = null, id2 = null) {
    const { data } = this;
    const triSet = /* @__PURE__ */ new Set();
    const arr = [];
    const addTriangles = (key) => {
      if (!data[key])
        return;
      if (id2 !== null) {
        if (data[key].intersects[id2]) {
          arr.push(data[key].intersects[id2]);
        }
      } else {
        const intersects = data[key].intersects;
        for (const key2 in intersects) {
          if (!triSet.has(key2)) {
            triSet.add(key2);
            arr.push(intersects[key2]);
          }
        }
      }
    };
    if (id !== null) {
      addTriangles(id);
    } else {
      for (const key in data) {
        addTriangles(key);
      }
    }
    return arr;
  }
  reset() {
    this.data = {};
  }
};
var OperationDebugData = class {
  constructor() {
    this.enabled = false;
    this.triangleIntersectsA = new TriangleIntersectionSets();
    this.triangleIntersectsB = new TriangleIntersectionSets();
    this.intersectionEdges = [];
  }
  addIntersectingTriangles(ia, triA, ib, triB) {
    const { triangleIntersectsA, triangleIntersectsB } = this;
    triangleIntersectsA.addTriangleIntersection(ia, triA, ib, triB);
    triangleIntersectsB.addTriangleIntersection(ib, triB, ia, triA);
  }
  addEdge(edge) {
    this.intersectionEdges.push(edge.clone());
  }
  reset() {
    this.triangleIntersectsA.reset();
    this.triangleIntersectsB.reset();
    this.intersectionEdges = [];
  }
};

// node_modules/three-bvh-csg/src/core/operations.js
var _matrix3 = new Matrix4();
var _normalMatrix = new Matrix3();
var _triA = new Triangle();
var _triB = new Triangle();
var _tri2 = new Triangle();
var _barycoordTri = new Triangle();
function getFirstIdFromSet(set) {
  for (const id of set)
    return id;
}
function performOperation(a, b, operation, splitter, typedAttributeData, options) {
  const { useGroups = true } = options;
  const { aIntersections, bIntersections } = collectIntersectingTriangles(a, b);
  const resultGroups = [];
  let resultMaterials = null;
  let groupOffset;
  groupOffset = useGroups ? 0 : -1;
  performWholeTriangleOperations(a, b, aIntersections, operation, false, typedAttributeData, groupOffset);
  performSplitTriangleOperations(a, b, aIntersections, operation, false, splitter, typedAttributeData, groupOffset);
  groupOffset = useGroups ? a.geometry.groups.length || 1 : -1;
  performWholeTriangleOperations(b, a, bIntersections, operation, true, typedAttributeData, groupOffset);
  performSplitTriangleOperations(b, a, bIntersections, operation, true, splitter, typedAttributeData, groupOffset);
  return {
    groups: resultGroups,
    materials: resultMaterials
  };
}
function performSplitTriangleOperations(a, b, intersectionMap, operation, invert, splitter, attributeInfo, groupOffset = 0) {
  const invertedGeometry = a.matrixWorld.determinant() < 0;
  _matrix3.copy(b.matrixWorld).invert().multiply(a.matrixWorld);
  _normalMatrix.getNormalMatrix(a.matrixWorld).multiplyScalar(invertedGeometry ? -1 : 1);
  const groupIndices = a.geometry.groupIndices;
  const aIndex = a.geometry.index;
  const aPosition = a.geometry.attributes.position;
  const bBVH = b.geometry.boundsTree;
  const bIndex = b.geometry.index;
  const bPosition = b.geometry.attributes.position;
  const splitIds = intersectionMap.ids;
  const intersectionSet = intersectionMap.intersectionSet;
  for (let i = 0, l = splitIds.length; i < l; i++) {
    const ia = splitIds[i];
    const groupIndex = groupOffset === -1 ? 0 : groupIndices[ia] + groupOffset;
    const attrSet = attributeInfo.getGroupSet(groupIndex);
    const ia3 = 3 * ia;
    const ia0 = aIndex.getX(ia3 + 0);
    const ia1 = aIndex.getX(ia3 + 1);
    const ia2 = aIndex.getX(ia3 + 2);
    _triA.a.fromBufferAttribute(aPosition, ia0).applyMatrix4(_matrix3);
    _triA.b.fromBufferAttribute(aPosition, ia1).applyMatrix4(_matrix3);
    _triA.c.fromBufferAttribute(aPosition, ia2).applyMatrix4(_matrix3);
    splitter.initialize(_triA);
    const intersectingIndices = intersectionSet[ia];
    for (let ib = 0, l2 = intersectingIndices.length; ib < l2; ib++) {
      const ib3 = 3 * intersectingIndices[ib];
      const ib0 = bIndex.getX(ib3 + 0);
      const ib1 = bIndex.getX(ib3 + 1);
      const ib2 = bIndex.getX(ib3 + 2);
      _triB.a.fromBufferAttribute(bPosition, ib0);
      _triB.b.fromBufferAttribute(bPosition, ib1);
      _triB.c.fromBufferAttribute(bPosition, ib2);
      splitter.splitByTriangle(_triB);
    }
    const triangles = splitter.triangles;
    for (let ib = 0, l2 = triangles.length; ib < l2; ib++) {
      const clippedTri = triangles[ib];
      const hitSide = getHitSide(clippedTri, bBVH);
      const action = getOperationAction(operation, hitSide, invert);
      if (action !== SKIP_TRI) {
        _triA.getBarycoord(clippedTri.a, _barycoordTri.a);
        _triA.getBarycoord(clippedTri.b, _barycoordTri.b);
        _triA.getBarycoord(clippedTri.c, _barycoordTri.c);
        const invertTri = action === INVERT_TRI;
        appendAttributeFromTriangle(ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri);
      }
    }
  }
  return splitIds.length;
}
function performWholeTriangleOperations(a, b, splitTriSet, operation, invert, attributeInfo, groupOffset = 0) {
  const invertedGeometry = a.matrixWorld.determinant() < 0;
  _matrix3.copy(b.matrixWorld).invert().multiply(a.matrixWorld);
  _normalMatrix.getNormalMatrix(a.matrixWorld).multiplyScalar(invertedGeometry ? -1 : 1);
  const bBVH = b.geometry.boundsTree;
  const groupIndices = a.geometry.groupIndices;
  const aIndex = a.geometry.index;
  const aAttributes = a.geometry.attributes;
  const aPosition = aAttributes.position;
  const stack = [];
  const halfEdges = a.geometry.halfEdges;
  const traverseSet = /* @__PURE__ */ new Set();
  for (let i = 0, l = aIndex.count / 3; i < l; i++) {
    if (!(i in splitTriSet.intersectionSet)) {
      traverseSet.add(i);
    }
  }
  while (traverseSet.size > 0) {
    const id = getFirstIdFromSet(traverseSet);
    traverseSet.delete(id);
    stack.push(id);
    const i3 = 3 * id;
    const i0 = aIndex.getX(i3 + 0);
    const i1 = aIndex.getX(i3 + 1);
    const i2 = aIndex.getX(i3 + 2);
    _tri2.a.fromBufferAttribute(aPosition, i0).applyMatrix4(_matrix3);
    _tri2.b.fromBufferAttribute(aPosition, i1).applyMatrix4(_matrix3);
    _tri2.c.fromBufferAttribute(aPosition, i2).applyMatrix4(_matrix3);
    const hitSide = getHitSide(_tri2, bBVH);
    const action = getOperationAction(operation, hitSide, invert);
    while (stack.length > 0) {
      const currId = stack.pop();
      const groupIndex = groupOffset === -1 ? 0 : groupIndices[currId] + groupOffset;
      const attrSet = attributeInfo.getGroupSet(groupIndex);
      for (let i = 0; i < 3; i++) {
        const sid = halfEdges.getSiblingTriangleIndex(currId, i);
        if (sid !== -1 && traverseSet.has(sid)) {
          stack.push(sid);
          traverseSet.delete(sid);
        }
      }
      if (action === SKIP_TRI) {
        continue;
      }
      const i32 = 3 * currId;
      const i02 = aIndex.getX(i32 + 0);
      const i12 = aIndex.getX(i32 + 1);
      const i22 = aIndex.getX(i32 + 2);
      const invertTri = action === INVERT_TRI;
      appendAttributesFromIndices(i02, i12, i22, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry);
    }
  }
}

// node_modules/three-bvh-csg/src/core/Evaluator.js
function applyToGeometry(geometry, referenceGeometry, groups, attributeInfo) {
  let needsDisposal = false;
  let drawRange = -1;
  const groupCount = attributeInfo.groupCount;
  const attributes = geometry.attributes;
  const rootAttrSet = attributeInfo.groupAttributes[0];
  for (const key in rootAttrSet) {
    const requiredLength = attributeInfo.getTotalLength(key, groupCount);
    const type = rootAttrSet[key].type;
    let attr = attributes[key];
    if (!attr || attr.array.length < requiredLength) {
      const refAttr = referenceGeometry.attributes[key];
      attr = new BufferAttribute(new type(requiredLength), refAttr.itemSize, refAttr.normalized);
      geometry.setAttribute(key, attr);
      needsDisposal = true;
    }
    let offset = 0;
    for (let i = 0; i < groupCount; i++) {
      const { array, type: type2, length } = attributeInfo.groupAttributes[i][key];
      const trimmedArray = new type2(array.buffer, 0, length);
      attr.array.set(trimmedArray, offset);
      offset += trimmedArray.length;
    }
    attr.needsUpdate = true;
    drawRange = requiredLength / attr.itemSize;
  }
  geometry.setDrawRange(0, drawRange);
  geometry.clearGroups();
  let groupOffset = 0;
  for (let i = 0; i < groupCount; i++) {
    const posCount = attributeInfo.getGroupArray("position", i).length / 3;
    if (posCount !== 0) {
      const group = groups[i];
      geometry.addGroup(groupOffset, posCount, group.materialIndex);
      groupOffset += posCount;
    }
  }
  if (geometry.index) {
    const indexArray = geometry.index.array;
    if (indexArray.length < drawRange) {
      geometry.index = null;
      needsDisposal = true;
    } else {
      for (let i = 0, l = indexArray.length; i < l; i++) {
        indexArray[i] = i;
      }
    }
  }
  geometry.boundsTree = null;
  if (needsDisposal) {
    geometry.dispose();
  }
  return geometry;
}
function getMaterialList(groups, materials) {
  let result = materials;
  if (!Array.isArray(materials)) {
    result = [];
    groups.forEach((g) => {
      result[g.materialIndex] = materials;
    });
  }
  return result;
}
var Evaluator = class {
  constructor() {
    this.triangleSplitter = new TriangleSplitter();
    this.attributeData = new TypedAttributeData();
    this.attributes = ["position", "uv", "normal"];
    this.useGroups = true;
    this.debug = new OperationDebugData();
  }
  evaluate(a, b, operation, targetBrush = new Brush()) {
    a.prepareGeometry();
    b.prepareGeometry();
    const { triangleSplitter, attributeData, attributes, useGroups, debug } = this;
    const targetGeometry = targetBrush.geometry;
    const aAttributes = a.geometry.attributes;
    for (let i = 0, l = attributes.length; i < l; i++) {
      const key = attributes[i];
      const attr = aAttributes[key];
      attributeData.initializeArray(key, attr.array.constructor);
    }
    for (const key in attributeData.attributes) {
      if (!attributes.includes(key)) {
        attributeData.delete(key);
      }
    }
    for (const key in targetGeometry.attributes) {
      if (!attributes.includes(key)) {
        targetGeometry.deleteAttribute(key);
        targetGeometry.dispose();
      }
    }
    attributeData.clear();
    if (debug.enabled) {
      debug.reset();
      setDebugContext(debug);
    }
    performOperation(a, b, operation, triangleSplitter, attributeData, { useGroups });
    if (debug.enabled) {
      setDebugContext(null);
    }
    const aGroups = !useGroups || a.geometry.groups.length === 0 ? [{ start: 0, count: Infinity, materialIndex: 0 }] : a.geometry.groups.map((group) => ({ ...group }));
    const bGroups = !useGroups || b.geometry.groups.length === 0 ? [{ start: 0, count: Infinity, materialIndex: 0 }] : b.geometry.groups.map((group) => ({ ...group }));
    const aMaterials = getMaterialList(aGroups, a.material);
    const bMaterials = getMaterialList(bGroups, b.material);
    bGroups.forEach((g) => {
      g.materialIndex += aMaterials.length;
    });
    applyToGeometry(targetGeometry, a.geometry, [...aGroups, ...bGroups], attributeData);
    const groups = targetGeometry.groups;
    if (useGroups) {
      const materialMap = /* @__PURE__ */ new Map();
      const allMaterials = [...aMaterials, ...bMaterials];
      let newIndex = 0;
      for (let i = 0, l = allMaterials.length; i < l; i++) {
        const foundGroup = Boolean(groups.find((group) => group.materialIndex === i));
        if (!foundGroup) {
          allMaterials[i] = null;
        } else {
          materialMap.set(i, newIndex);
          newIndex++;
        }
      }
      for (let i = 0, l = groups.length; i < l; i++) {
        const group = groups[i];
        group.materialIndex = materialMap.get(group.materialIndex);
      }
      targetBrush.material = allMaterials.filter((material) => material);
    }
    return targetBrush;
  }
  evaluateHierarchy(root, target = new Brush()) {
    root.updateMatrixWorld(true);
    const flatTraverse = (obj, cb) => {
      const children = obj.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        if (child.isOperationGroup) {
          flatTraverse(child, cb);
        } else {
          cb(child);
        }
      }
    };
    const traverse = (brush) => {
      const children = brush.children;
      let didChange = false;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        didChange = traverse(child) || didChange;
      }
      const isDirty = brush.isDirty();
      if (isDirty) {
        brush.markUpdated();
      }
      if (didChange && !brush.isOperationGroup) {
        let result;
        flatTraverse(brush, (child) => {
          if (!result) {
            result = this.evaluate(brush, child, child.operation);
          } else {
            result = this.evaluate(result, child, child.operation);
          }
        });
        brush._cachedGeometry = result.geometry;
        brush._cachedMaterials = result.material;
        return true;
      } else {
        return didChange || isDirty;
      }
    };
    traverse(root);
    target.geometry = root._cachedGeometry;
    target.material = root._cachedMaterials;
    return target;
  }
  reset() {
    this.triangleSplitter.reset();
  }
};

// node_modules/three-bvh-csg/src/core/Operation.js
var Operation = class extends Brush {
  constructor(...args) {
    super(...args);
    this.isOperation = true;
    this.operation = ADDITION;
    this._cachedGeometry = new BufferGeometry();
    this._cachedMaterials = null;
    this._previousOperation = null;
  }
  markUpdated() {
    super.markUpdated();
    this._previousOperation = this.operation;
  }
  isDirty() {
    return this.operation !== this._previousOperation || super.isDirty();
  }
  insertBefore(brush) {
    const parent = this.parent;
    const index = parent.children.indexOf(this);
    parent.children.splice(index, 0, brush);
  }
  insertAfter(brush) {
    const parent = this.parent;
    const index = parent.children.indexOf(this);
    parent.children.splice(index + 1, 0, brush);
  }
};

// node_modules/three-bvh-csg/src/core/OperationGroup.js
var OperationGroup = class extends Group {
  constructor() {
    super();
    this.isOperationGroup = true;
    this._previousMatrix = new Matrix4();
  }
  markUpdated() {
    this._previousMatrix.copy(this.matrix);
  }
  isDirty() {
    const { matrix, _previousMatrix } = this;
    const el1 = matrix.elements;
    const el2 = _previousMatrix.elements;
    for (let i = 0; i < 16; i++) {
      if (el1[i] !== el2[i]) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/three-bvh-csg/src/materials/shaderUtils.js
function addWorldPosition(shader) {
  if (/varying\s+vec3\s+wPosition/.test(shader.vertexShader))
    return;
  shader.vertexShader = `
			varying vec3 wPosition;
			${shader.vertexShader}
		`.replace(
    /#include <displacementmap_vertex>/,
    (v) => `${v}
				wPosition = (modelMatrix * vec4( transformed, 1.0 )).xyz;
				`
  );
  shader.fragmentShader = `
		varying vec3 wPosition;
		${shader.fragmentShader}
		`;
  return shader;
}
function csgGridShaderMixin(shader) {
  shader.uniforms = {
    ...shader.uniforms,
    checkerboardColor: { value: new Color(1118481) }
  };
  addWorldPosition(shader);
  shader.defines = { CSG_GRID: 1 };
  shader.fragmentShader = shader.fragmentShader.replace(
    /#include <common>/,
    (v) => (
      /* glsl */
      `
			${v}

			uniform vec3 checkerboardColor;
			float getCheckerboard( vec2 p, float scale ) {

				p /= scale;
				p += vec2( 0.5 );

				vec2 line = mod( p, 2.0 ) - vec2( 1.0 );
				line = abs( line );

				vec2 pWidth = fwidth( line );
				vec2 value = smoothstep( 0.5 - pWidth / 2.0, 0.5 + pWidth / 2.0, line );
				float result = value.x * value.y + ( 1.0 - value.x ) * ( 1.0 - value.y );

				return result;

			}

			float getGrid( vec2 p, float scale, float thickness ) {

				p /= 0.5 * scale;

				vec2 stride = mod( p, 2.0 ) - vec2( 1.0 );
				stride = abs( stride );

				vec2 pWidth = fwidth( p );
				vec2 line = smoothstep( 1.0 - pWidth / 2.0, 1.0 + pWidth / 2.0, stride + thickness * pWidth );

				return max( line.x, line.y );

			}

			vec3 getFaceColor( vec2 p, vec3 color ) {

				float checkLarge = getCheckerboard( p, 1.0 );
				float checkSmall = abs( getCheckerboard( p, 0.1 ) );
				float lines = getGrid( p, 10.0, 1.0 );

				vec3 checkColor = mix(
					vec3( 0.7 ) * color,
					vec3( 1.0 ) * color,
					checkSmall * 0.4 + checkLarge * 0.6
				);

				vec3 gridColor = vec3( 1.0 );

				return mix( checkColor, gridColor, lines );

			}

			float angleBetween( vec3 a, vec3 b ) {

				return acos( abs( dot( a, b ) ) );

			}

			vec3 planeProject( vec3 norm, vec3 other ) {

				float d = dot( norm, other );
				return normalize( other - norm * d );

			}

			vec3 getBlendFactors( vec3 norm ) {

				vec3 xVec = vec3( 1.0, 0.0, 0.0 );
				vec3 yVec = vec3( 0.0, 1.0, 0.0 );
				vec3 zVec = vec3( 0.0, 0.0, 1.0 );

				vec3 projX = planeProject( xVec, norm );
				vec3 projY = planeProject( yVec, norm );
				vec3 projZ = planeProject( zVec, norm );

				float xAngle = max(
					angleBetween( xVec, projY ),
					angleBetween( xVec, projZ )
				);

				float yAngle = max(
					angleBetween( yVec, projX ),
					angleBetween( yVec, projZ )
				);

				float zAngle = max(
					angleBetween( zVec, projX ),
					angleBetween( zVec, projY )
				);

				return vec3( xAngle, yAngle, zAngle ) / ( 0.5 * PI );

			}
		`
    )
  ).replace(
    /#include <normal_fragment_maps>/,
    (v) => (
      /* glsl */
      `${v}
				#if CSG_GRID
				{

					vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

					float yCont = abs( dot( vec3( 0.0, 1.0, 0.0 ), worldNormal ) );
					float zCont = abs( dot( vec3( 0.0, 0.0, 1.0 ), worldNormal ) );
					float xCont = abs( dot( vec3( 1.0, 0.0, 0.0 ), worldNormal ) );

					vec3 factors = getBlendFactors( worldNormal );
					factors = smoothstep( vec3( 0.475 ), vec3( 0.525 ), vec3( 1.0 ) - factors );

					float weight = factors.x + factors.y + factors.z;
					factors /= weight;

					vec3 color =
						getFaceColor( wPosition.yz, diffuseColor.rgb ) * factors.x +
						getFaceColor( wPosition.xz, diffuseColor.rgb ) * factors.y +
						getFaceColor( wPosition.xy, diffuseColor.rgb ) * factors.z;

					diffuseColor.rgb = color;

				}
				#endif
				`
    )
  );
  return shader;
}

// node_modules/three-bvh-csg/src/materials/GridMaterial.js
var GridMaterial = class extends MeshPhongMaterial {
  get enableGrid() {
    return Boolean(this._enableGrid);
  }
  set enableGrid(v) {
    if (this._enableGrid !== v) {
      this._enableGrid = v;
      this.needsUpdate = true;
    }
  }
  constructor(...args) {
    super(...args);
    this.enableGrid = true;
  }
  onBeforeCompile(shader) {
    csgGridShaderMixin(shader);
    shader.defines.CSG_GRID = Number(this.enableGrid);
  }
  customProgramCacheKey() {
    return this.enableGrid.toString();
  }
};

// node_modules/three-bvh-csg/src/core/debugUtils.js
function getTriangleDefinitions(...triangles) {
  function getVectorDefinition(v) {
    return (
      /* js */
      `new THREE.Vector3( ${v.x}, ${v.y}, ${v.z} )`
    );
  }
  return triangles.map((t) => {
    return (
      /* js */
      `
			new THREE.Triangle(
				${getVectorDefinition(t.a)},
				${getVectorDefinition(t.b)},
				${getVectorDefinition(t.c)},
			)`.substring(1)
    );
  });
}
function logTriangleDefinitions(...triangles) {
  console.log(getTriangleDefinitions(...triangles).join(",\n"));
}
function generateRandomTriangleColors(geometry) {
  const position = geometry.attributes.position;
  const array = new Float32Array(position.count * 3);
  const color = new Color();
  for (let i = 0, l = array.length; i < l; i += 9) {
    color.setHSL(
      Math.random(),
      MathUtils.lerp(0.5, 1, Math.random()),
      MathUtils.lerp(0.5, 0.75, Math.random())
    );
    array[i + 0] = color.r;
    array[i + 1] = color.g;
    array[i + 2] = color.b;
    array[i + 3] = color.r;
    array[i + 4] = color.g;
    array[i + 5] = color.b;
    array[i + 6] = color.r;
    array[i + 7] = color.g;
    array[i + 8] = color.b;
  }
  geometry.setAttribute("color", new BufferAttribute(array, 3));
}

// node_modules/three-bvh-csg/src/objects/TriangleSetHelper.js
var TriangleSetHelper = class extends Group {
  get color() {
    return this._mesh.material.color;
  }
  get side() {
    return this._mesh.material.side;
  }
  set side(v) {
    this._mesh.material.side = v;
  }
  constructor(triangles = []) {
    super();
    const geometry = new BufferGeometry();
    const lineGeom = new BufferGeometry();
    this._mesh = new Mesh(geometry, new MeshPhongMaterial({
      flatShading: true,
      transparent: true,
      opacity: 0.25
    }));
    this._lines = new LineSegments(lineGeom, new LineBasicMaterial());
    this._mesh.material.color = this._lines.material.color;
    this._lines.frustumCulled = false;
    this._mesh.frustumCulled = false;
    this.add(this._lines, this._mesh);
    this.setTriangles(triangles);
  }
  setTriangles(triangles) {
    const triPositions = new Float32Array(3 * 3 * triangles.length);
    const linePositions = new Float32Array(6 * 3 * triangles.length);
    for (let i = 0, l = triangles.length; i < l; i++) {
      const i9 = 9 * i;
      const i18 = 18 * i;
      const tri = triangles[i];
      tri.a.toArray(triPositions, i9 + 0);
      tri.b.toArray(triPositions, i9 + 3);
      tri.c.toArray(triPositions, i9 + 6);
      tri.a.toArray(linePositions, i18 + 0);
      tri.b.toArray(linePositions, i18 + 3);
      tri.b.toArray(linePositions, i18 + 6);
      tri.c.toArray(linePositions, i18 + 9);
      tri.c.toArray(linePositions, i18 + 12);
      tri.a.toArray(linePositions, i18 + 15);
    }
    this._mesh.geometry.dispose();
    this._mesh.geometry.setAttribute("position", new BufferAttribute(triPositions, 3));
    this._lines.geometry.dispose();
    this._lines.geometry.setAttribute("position", new BufferAttribute(linePositions, 3));
  }
};

// node_modules/three-bvh-csg/src/objects/EdgesHelper.js
var EdgesHelper = class extends LineSegments {
  get color() {
    return this.material.color;
  }
  constructor(edges = []) {
    super();
    this.frustumCulled = false;
    this.setEdges(edges);
  }
  setEdges(edges) {
    const { geometry } = this;
    const points = edges.flatMap((e) => [e.start, e.end]);
    geometry.dispose();
    geometry.setFromPoints(points);
  }
};

// node_modules/three-bvh-csg/src/objects/PointsHelper.js
var _matrix4 = new Matrix4();
var PointsHelper = class extends InstancedMesh {
  get color() {
    return this.material.color;
  }
  constructor(count = 1e3, points = []) {
    super(new SphereGeometry(0.025), new MeshBasicMaterial(), count);
    this.frustumCulled = false;
    this.setPoints(points);
  }
  setPoints(points) {
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      _matrix4.makeTranslation(point.x, point.y, point.z);
      this.setMatrixAt(i, _matrix4);
    }
    this.count = points.length;
  }
};

// node_modules/three-bvh-csg/src/objects/HalfEdgeHelper.js
var _tri1 = new Triangle();
var _tri22 = new Triangle();
var _center = new Vector3();
var _center2 = new Vector3();
var _edgeCenter = new Vector3();
var _edgeCenter2 = new Vector3();
var _projected = new Vector3();
var _projected2 = new Vector3();
var _projectedDir = new Vector3();
var _projectedDir2 = new Vector3();
var _edgeDir = new Vector3();
var _edgeDir2 = new Vector3();
var _vec4 = new Vector3();
var _vec22 = new Vector3();
var _finalPoint = new Vector3();
var _finalPoint2 = new Vector3();
var _plane2 = new Plane();
var _plane22 = new Plane();
function getTriangle(geometry, triIndex, target) {
  const i3 = 3 * triIndex;
  let i0 = i3 + 0;
  let i1 = i3 + 1;
  let i2 = i3 + 2;
  const indexAttr = geometry.index;
  const posAttr = geometry.attributes.position;
  if (indexAttr) {
    i0 = indexAttr.getX(i0);
    i1 = indexAttr.getX(i1);
    i2 = indexAttr.getX(i2);
  }
  target.a.fromBufferAttribute(posAttr, i0);
  target.b.fromBufferAttribute(posAttr, i1);
  target.c.fromBufferAttribute(posAttr, i2);
  return target;
}
var HalfEdgeHelper = class extends EdgesHelper {
  constructor(geometry = null, halfEdges = null) {
    super();
    if (geometry && halfEdges) {
      this.setHalfEdges(geometry, halfEdges);
    }
  }
  setHalfEdges(geometry, halfEdges) {
    const indexAttr = geometry.index;
    const posAttr = geometry.attributes.position;
    const vertKeys = ["a", "b", "c"];
    const edges = [];
    const triCount = indexAttr ? indexAttr.count / 3 : posAttr.count / 3;
    for (let triIndex = 0; triIndex < triCount; triIndex++) {
      getTriangle(geometry, triIndex, _tri1);
      _tri1.getMidpoint(_center);
      _tri1.getPlane(_plane2);
      for (let e = 0; e < 3; e++) {
        const otherTriIndex = halfEdges.getSiblingTriangleIndex(triIndex, e);
        const otherEdgeIndex = halfEdges.getSiblingEdgeIndex(triIndex, e);
        if (otherTriIndex === -1) {
          continue;
        }
        getTriangle(geometry, otherTriIndex, _tri22);
        _tri22.getPlane(_plane22);
        _tri22.getMidpoint(_center2);
        {
          const nextE = (e + 1) % 3;
          const v0 = _tri1[vertKeys[e]];
          const v1 = _tri1[vertKeys[nextE]];
          _edgeCenter.lerpVectors(v0, v1, 0.5);
        }
        {
          const nextE = (otherEdgeIndex + 1) % 3;
          const v0 = _tri22[vertKeys[otherEdgeIndex]];
          const v1 = _tri22[vertKeys[nextE]];
          _edgeCenter2.lerpVectors(v0, v1, 0.5);
        }
        _plane2.projectPoint(_center2, _projected);
        _plane22.projectPoint(_center, _projected2);
        _projectedDir.subVectors(_projected, _center);
        _projectedDir2.subVectors(_projected2, _center2);
        _edgeDir.subVectors(_edgeCenter, _center);
        _edgeDir2.subVectors(_edgeCenter2, _center2);
        if (_projectedDir.dot(_edgeDir) < 0) {
          _projectedDir.multiplyScalar(-1);
        }
        if (_projectedDir2.dot(_edgeDir2) < 0) {
          _projectedDir2.multiplyScalar(-1);
        }
        _vec4.addVectors(_center, _projectedDir);
        _vec22.addVectors(_center2, _projectedDir2);
        _tri1.closestPointToPoint(_vec4, _finalPoint);
        _tri22.closestPointToPoint(_vec22, _finalPoint2);
        const edge = new Line3();
        edge.start.copy(_center);
        edge.end.lerpVectors(_finalPoint, _finalPoint2, 0.5);
        edges.push(edge);
      }
    }
    super.setEdges(edges);
  }
};

// node_modules/three-bvh-csg/src/utils/computeMeshVolume.js
var _tri3 = new Triangle();
var _normal2 = new Vector3();
var _relPoint = new Vector3();
function computeMeshVolume(mesh) {
  let geometry;
  let matrix;
  if (mesh.isBufferGeometry) {
    geometry = mesh;
    matrix = null;
  } else {
    geometry = mesh.geometry;
    matrix = Math.abs(mesh.matrixWorld.determinant() - 1) < 1e-15 ? null : mesh.matrixWorld;
  }
  const index = geometry.index;
  const pos = geometry.attributes.position;
  const drawRange = geometry.drawRange;
  const triCount = Math.min((index ? index.count : pos.count) / 3, drawRange.count / 3);
  _tri3.setFromAttributeAndIndices(pos, 0, 1, 2);
  applyMatrix4ToTri(_tri3, matrix);
  _tri3.getNormal(_normal2);
  _tri3.getMidpoint(_relPoint).add(_normal2);
  let volume = 0;
  const startIndex = drawRange.start / 3;
  for (let i = startIndex, l = startIndex + triCount; i < l; i++) {
    let i0 = 3 * i + 0;
    let i1 = 3 * i + 1;
    let i2 = 3 * i + 2;
    if (index) {
      i0 = index.getX(i0);
      i1 = index.getX(i1);
      i2 = index.getX(i2);
    }
    _tri3.setFromAttributeAndIndices(pos, i0, i1, i2);
    applyMatrix4ToTri(_tri3, matrix);
    subVectorFromTri(_tri3, _relPoint);
    volume += signedVolumeOfTriangle(_tri3.a, _tri3.b, _tri3.c);
  }
  return Math.abs(volume);
}
function signedVolumeOfTriangle(p1, p2, p3) {
  const v321 = p3.x * p2.y * p1.z;
  const v231 = p2.x * p3.y * p1.z;
  const v312 = p3.x * p1.y * p2.z;
  const v132 = p1.x * p3.y * p2.z;
  const v213 = p2.x * p1.y * p3.z;
  const v123 = p1.x * p2.y * p3.z;
  return 1 / 6 * (-v321 + v231 + v312 - v132 - v213 + v123);
}
function subVectorFromTri(tri, pos) {
  tri.a.sub(pos);
  tri.b.sub(pos);
  tri.c.sub(pos);
}
function applyMatrix4ToTri(tri, mat = null) {
  if (mat !== null) {
    tri.a.applyMatrix4(mat);
    tri.b.applyMatrix4(mat);
    tri.c.applyMatrix4(mat);
  }
}
export {
  ADDITION,
  Brush,
  DIFFERENCE,
  EdgesHelper,
  Evaluator,
  GridMaterial,
  HalfEdgeHelper,
  HalfEdgeMap,
  INTERSECTION,
  Operation,
  OperationGroup,
  PointsHelper,
  SUBTRACTION,
  TriangleSetHelper,
  TriangleSplitter,
  computeMeshVolume,
  generateRandomTriangleColors,
  getTriangleDefinitions,
  isTriDegenerate,
  logTriangleDefinitions
};
//# sourceMappingURL=three-bvh-csg.js.map
